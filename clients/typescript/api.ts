/* tslint:disable */
/* eslint-disable */
/**
 * Smoketree
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: support@kwila.cloud
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface GetLimitsGetAll200ResponseInner
 */
export interface GetLimitsGetAll200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof GetLimitsGetAll200ResponseInner
     */
    'month': string;
    /**
     * 
     * @type {number}
     * @memberof GetLimitsGetAll200ResponseInner
     */
    'segmentLimit': number;
    /**
     * 
     * @type {string}
     * @memberof GetLimitsGetAll200ResponseInner
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface GetMessageFetch404Response
 */
export interface GetMessageFetch404Response {
    /**
     * 
     * @type {string}
     * @memberof GetMessageFetch404Response
     */
    'error': string;
}
/**
 * 
 * @export
 * @interface GetMessageList200Response
 */
export interface GetMessageList200Response {
    /**
     * 
     * @type {Array<GetMessageList200ResponseMessagesInner>}
     * @memberof GetMessageList200Response
     */
    'messages': Array<GetMessageList200ResponseMessagesInner>;
    /**
     * 
     * @type {number}
     * @memberof GetMessageList200Response
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof GetMessageList200Response
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof GetMessageList200Response
     */
    'offset': number;
}
/**
 * 
 * @export
 * @interface GetMessageList200ResponseMessagesInner
 */
export interface GetMessageList200ResponseMessagesInner {
    /**
     * 
     * @type {string}
     * @memberof GetMessageList200ResponseMessagesInner
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof GetMessageList200ResponseMessagesInner
     */
    'organizationUuid': string;
    /**
     * 
     * @type {string}
     * @memberof GetMessageList200ResponseMessagesInner
     */
    'to': string;
    /**
     * 
     * @type {string}
     * @memberof GetMessageList200ResponseMessagesInner
     */
    'content': string;
    /**
     * 
     * @type {number}
     * @memberof GetMessageList200ResponseMessagesInner
     */
    'segments': number | null;
    /**
     * 
     * @type {string}
     * @memberof GetMessageList200ResponseMessagesInner
     */
    'currentStatus': string;
    /**
     * 
     * @type {string}
     * @memberof GetMessageList200ResponseMessagesInner
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof GetMessageList200ResponseMessagesInner
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface GetUsageStatsGetAll200ResponseInner
 */
export interface GetUsageStatsGetAll200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof GetUsageStatsGetAll200ResponseInner
     */
    'month': string;
    /**
     * 
     * @type {number}
     * @memberof GetUsageStatsGetAll200ResponseInner
     */
    'totalMessages': number;
    /**
     * 
     * @type {number}
     * @memberof GetUsageStatsGetAll200ResponseInner
     */
    'totalSegments': number;
    /**
     * 
     * @type {number}
     * @memberof GetUsageStatsGetAll200ResponseInner
     */
    'segmentLimit': number;
}
/**
 * 
 * @export
 * @interface PostMessageCreate200Response
 */
export interface PostMessageCreate200Response {
    /**
     * 
     * @type {Array<PostMessageCreate200ResponseResultsInner>}
     * @memberof PostMessageCreate200Response
     */
    'results': Array<PostMessageCreate200ResponseResultsInner>;
}
/**
 * 
 * @export
 * @interface PostMessageCreate200ResponseResultsInner
 */
export interface PostMessageCreate200ResponseResultsInner {
    /**
     * 
     * @type {string}
     * @memberof PostMessageCreate200ResponseResultsInner
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof PostMessageCreate200ResponseResultsInner
     */
    'organizationUuid': string;
    /**
     * 
     * @type {string}
     * @memberof PostMessageCreate200ResponseResultsInner
     */
    'to': string;
    /**
     * 
     * @type {string}
     * @memberof PostMessageCreate200ResponseResultsInner
     */
    'content': string;
    /**
     * 
     * @type {number}
     * @memberof PostMessageCreate200ResponseResultsInner
     */
    'segments': number | null;
    /**
     * 
     * @type {string}
     * @memberof PostMessageCreate200ResponseResultsInner
     */
    'currentStatus': string;
    /**
     * 
     * @type {string}
     * @memberof PostMessageCreate200ResponseResultsInner
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof PostMessageCreate200ResponseResultsInner
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof PostMessageCreate200ResponseResultsInner
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface PostMessageCreate429Response
 */
export interface PostMessageCreate429Response {
    /**
     * 
     * @type {string}
     * @memberof PostMessageCreate429Response
     */
    'error': string;
    /**
     * 
     * @type {string}
     * @memberof PostMessageCreate429Response
     */
    'messageUuid': string;
    /**
     * 
     * @type {number}
     * @memberof PostMessageCreate429Response
     */
    'currentUsage': number;
    /**
     * 
     * @type {number}
     * @memberof PostMessageCreate429Response
     */
    'monthlyLimit': number;
}
/**
 * 
 * @export
 * @interface PostMessageCreateRequest
 */
export interface PostMessageCreateRequest {
    /**
     * 
     * @type {Array<PostMessageCreateRequestMessagesInner>}
     * @memberof PostMessageCreateRequest
     */
    'messages': Array<PostMessageCreateRequestMessagesInner>;
}
/**
 * 
 * @export
 * @interface PostMessageCreateRequestMessagesInner
 */
export interface PostMessageCreateRequestMessagesInner {
    /**
     * 
     * @type {string}
     * @memberof PostMessageCreateRequestMessagesInner
     */
    'to': string;
    /**
     * 
     * @type {string}
     * @memberof PostMessageCreateRequestMessagesInner
     */
    'content': string;
}
/**
 * 
 * @export
 * @interface PutLimitsPutRequest
 */
export interface PutLimitsPutRequest {
    /**
     * 
     * @type {number}
     * @memberof PutLimitsPutRequest
     */
    'segmentLimit': number;
}

/**
 * LimitsApi - axios parameter creator
 * @export
 */
export const LimitsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get All Monthly Limits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLimitsGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/limits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Monthly Limit by Month
         * @param {string} month 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLimitsGetByMonth: async (month: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'month' is not null or undefined
            assertParamExists('getLimitsGetByMonth', 'month', month)
            const localVarPath = `/api/v1/limits/{month}`
                .replace(`{${"month"}}`, encodeURIComponent(String(month)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set Monthly Limit (Admin Only)
         * @param {string} month 
         * @param {PutLimitsPutRequest} [putLimitsPutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putLimitsPut: async (month: string, putLimitsPutRequest?: PutLimitsPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'month' is not null or undefined
            assertParamExists('putLimitsPut', 'month', month)
            const localVarPath = `/api/v1/limits/{month}`
                .replace(`{${"month"}}`, encodeURIComponent(String(month)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(putLimitsPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LimitsApi - functional programming interface
 * @export
 */
export const LimitsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LimitsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get All Monthly Limits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLimitsGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetLimitsGetAll200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLimitsGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LimitsApi.getLimitsGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Monthly Limit by Month
         * @param {string} month 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLimitsGetByMonth(month: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLimitsGetAll200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLimitsGetByMonth(month, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LimitsApi.getLimitsGetByMonth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set Monthly Limit (Admin Only)
         * @param {string} month 
         * @param {PutLimitsPutRequest} [putLimitsPutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putLimitsPut(month: string, putLimitsPutRequest?: PutLimitsPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLimitsGetAll200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putLimitsPut(month, putLimitsPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LimitsApi.putLimitsPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LimitsApi - factory interface
 * @export
 */
export const LimitsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LimitsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get All Monthly Limits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLimitsGetAll(options?: RawAxiosRequestConfig): AxiosPromise<Array<GetLimitsGetAll200ResponseInner>> {
            return localVarFp.getLimitsGetAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Monthly Limit by Month
         * @param {string} month 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLimitsGetByMonth(month: string, options?: RawAxiosRequestConfig): AxiosPromise<GetLimitsGetAll200ResponseInner> {
            return localVarFp.getLimitsGetByMonth(month, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set Monthly Limit (Admin Only)
         * @param {string} month 
         * @param {PutLimitsPutRequest} [putLimitsPutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putLimitsPut(month: string, putLimitsPutRequest?: PutLimitsPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetLimitsGetAll200ResponseInner> {
            return localVarFp.putLimitsPut(month, putLimitsPutRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LimitsApi - object-oriented interface
 * @export
 * @class LimitsApi
 * @extends {BaseAPI}
 */
export class LimitsApi extends BaseAPI {
    /**
     * 
     * @summary Get All Monthly Limits
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LimitsApi
     */
    public getLimitsGetAll(options?: RawAxiosRequestConfig) {
        return LimitsApiFp(this.configuration).getLimitsGetAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Monthly Limit by Month
     * @param {string} month 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LimitsApi
     */
    public getLimitsGetByMonth(month: string, options?: RawAxiosRequestConfig) {
        return LimitsApiFp(this.configuration).getLimitsGetByMonth(month, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set Monthly Limit (Admin Only)
     * @param {string} month 
     * @param {PutLimitsPutRequest} [putLimitsPutRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LimitsApi
     */
    public putLimitsPut(month: string, putLimitsPutRequest?: PutLimitsPutRequest, options?: RawAxiosRequestConfig) {
        return LimitsApiFp(this.configuration).putLimitsPut(month, putLimitsPutRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MessagesApi - axios parameter creator
 * @export
 */
export const MessagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Message Status
         * @param {string} messageUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageFetch: async (messageUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'messageUuid' is not null or undefined
            assertParamExists('getMessageFetch', 'messageUuid', messageUuid)
            const localVarPath = `/api/v1/messages/{messageUuid}`
                .replace(`{${"messageUuid"}}`, encodeURIComponent(String(messageUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Messages
         * @param {string} [status] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageList: async (status?: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send SMS Messages
         * @param {PostMessageCreateRequest} [postMessageCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMessageCreate: async (postMessageCreateRequest?: PostMessageCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postMessageCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retry Message
         * @param {string} messageUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMessageRetry: async (messageUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'messageUuid' is not null or undefined
            assertParamExists('postMessageRetry', 'messageUuid', messageUuid)
            const localVarPath = `/api/v1/messages/{messageUuid}/retry`
                .replace(`{${"messageUuid"}}`, encodeURIComponent(String(messageUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MessagesApi - functional programming interface
 * @export
 */
export const MessagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MessagesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Message Status
         * @param {string} messageUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessageFetch(messageUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMessageList200ResponseMessagesInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMessageFetch(messageUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagesApi.getMessageFetch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Messages
         * @param {string} [status] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessageList(status?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMessageList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMessageList(status, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagesApi.getMessageList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Send SMS Messages
         * @param {PostMessageCreateRequest} [postMessageCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postMessageCreate(postMessageCreateRequest?: PostMessageCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostMessageCreate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postMessageCreate(postMessageCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagesApi.postMessageCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retry Message
         * @param {string} messageUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postMessageRetry(messageUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMessageList200ResponseMessagesInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postMessageRetry(messageUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagesApi.postMessageRetry']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MessagesApi - factory interface
 * @export
 */
export const MessagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MessagesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Message Status
         * @param {string} messageUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageFetch(messageUuid: string, options?: RawAxiosRequestConfig): AxiosPromise<GetMessageList200ResponseMessagesInner> {
            return localVarFp.getMessageFetch(messageUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Messages
         * @param {string} [status] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageList(status?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<GetMessageList200Response> {
            return localVarFp.getMessageList(status, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send SMS Messages
         * @param {PostMessageCreateRequest} [postMessageCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMessageCreate(postMessageCreateRequest?: PostMessageCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<PostMessageCreate200Response> {
            return localVarFp.postMessageCreate(postMessageCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retry Message
         * @param {string} messageUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMessageRetry(messageUuid: string, options?: RawAxiosRequestConfig): AxiosPromise<GetMessageList200ResponseMessagesInner> {
            return localVarFp.postMessageRetry(messageUuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MessagesApi - object-oriented interface
 * @export
 * @class MessagesApi
 * @extends {BaseAPI}
 */
export class MessagesApi extends BaseAPI {
    /**
     * 
     * @summary Get Message Status
     * @param {string} messageUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public getMessageFetch(messageUuid: string, options?: RawAxiosRequestConfig) {
        return MessagesApiFp(this.configuration).getMessageFetch(messageUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Messages
     * @param {string} [status] 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public getMessageList(status?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return MessagesApiFp(this.configuration).getMessageList(status, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send SMS Messages
     * @param {PostMessageCreateRequest} [postMessageCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public postMessageCreate(postMessageCreateRequest?: PostMessageCreateRequest, options?: RawAxiosRequestConfig) {
        return MessagesApiFp(this.configuration).postMessageCreate(postMessageCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retry Message
     * @param {string} messageUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public postMessageRetry(messageUuid: string, options?: RawAxiosRequestConfig) {
        return MessagesApiFp(this.configuration).postMessageRetry(messageUuid, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsageApi - axios parameter creator
 * @export
 */
export const UsageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get All Usage Statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsageStatsGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/usage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Usage Statistics by Month
         * @param {string} month 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsageStatsGetByMonth: async (month: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'month' is not null or undefined
            assertParamExists('getUsageStatsGetByMonth', 'month', month)
            const localVarPath = `/api/v1/usage/{month}`
                .replace(`{${"month"}}`, encodeURIComponent(String(month)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsageApi - functional programming interface
 * @export
 */
export const UsageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsageApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get All Usage Statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsageStatsGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetUsageStatsGetAll200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsageStatsGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsageApi.getUsageStatsGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Usage Statistics by Month
         * @param {string} month 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsageStatsGetByMonth(month: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUsageStatsGetAll200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsageStatsGetByMonth(month, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsageApi.getUsageStatsGetByMonth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsageApi - factory interface
 * @export
 */
export const UsageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsageApiFp(configuration)
    return {
        /**
         * 
         * @summary Get All Usage Statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsageStatsGetAll(options?: RawAxiosRequestConfig): AxiosPromise<Array<GetUsageStatsGetAll200ResponseInner>> {
            return localVarFp.getUsageStatsGetAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Usage Statistics by Month
         * @param {string} month 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsageStatsGetByMonth(month: string, options?: RawAxiosRequestConfig): AxiosPromise<GetUsageStatsGetAll200ResponseInner> {
            return localVarFp.getUsageStatsGetByMonth(month, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsageApi - object-oriented interface
 * @export
 * @class UsageApi
 * @extends {BaseAPI}
 */
export class UsageApi extends BaseAPI {
    /**
     * 
     * @summary Get All Usage Statistics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageApi
     */
    public getUsageStatsGetAll(options?: RawAxiosRequestConfig) {
        return UsageApiFp(this.configuration).getUsageStatsGetAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Usage Statistics by Month
     * @param {string} month 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageApi
     */
    public getUsageStatsGetByMonth(month: string, options?: RawAxiosRequestConfig) {
        return UsageApiFp(this.configuration).getUsageStatsGetByMonth(month, options).then((request) => request(this.axios, this.basePath));
    }
}



